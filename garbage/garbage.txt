//void daemon_signal_handler(int sig);
//void log_message(char *filename,char *message);


//#include <signal.h>
//#include <stdio.h>
//#include <string.h>

//#define RUNNING_DIR "/home/linarcx"
//#define LOCK_FILE "daemond.lock"
//#define LOG_FILE "daemond.log"

// void daemon_signal_handler(int sig) {
//  switch (sig) {
//  case SIGHUP:
//    log_message(LOG_FILE, "Hangup Signal Catched.\n");
//    exit(0);
//    break;
//  case SIGINT:
//    log_message(LOG_FILE, "Interactive Attention Signal Catched.\n");
//    exit(0);
//    break;
//  case SIGKILL:
//    log_message(LOG_FILE, "Killed Signal Catched.\n");
//    exit(0);
//    break;
//  case SIGTERM:
//    show_nuklear_window();
//    log_message(LOG_FILE, "Terminate Signal Catched.\n");
//    exit(0);
//    break;
//  }
//}
//

//    chdir(RUNNING_DIR);
//
//    sprintf(str, "%d\n", getpid());
//    write(lfp, str, strlen(str));

//    lfp = open(LOCK_FILE, O_RDWR | O_CREAT, 0640);
//    if (lfp < 0)
//        exit(1);
//    if (lockf(lfp, F_TLOCK, 0) < 0)
//        exit(1);

//  signal(SIGCHLD, SIG_IGN);
//  signal(SIGTSTP, SIG_IGN);
//  signal(SIGTTOU, SIG_IGN);
//  signal(SIGTTIN, SIG_IGN);

//  signal(SIGHUP, daemon_signal_handler);
//  signal(SIGTERM, daemon_signal_handler);
//  signal(SIGINT, daemon_signal_handler);
//  signal(SIGKILL, daemon_signal_handler);





// detailed
// opt.flags = GIT_STATUS_OPT_DEFAULTS;
// error = git_status_list_new(&statuses, rep, &opt);
// if (error < 0)
//{
//    const git_error *e = giterr_last();
//    std::cout << "Error: " << error << " / " << e->klass << " : " <<
//    e->message << std::endl;

//    goto SHUTDOWN;
//}

// count = git_status_list_entrycount(statuses);
// std::cout<< "count: " << count << std::endl;
// for (size_t i = 0; i < count; ++i)
//{
//    const git_status_entry* entry = git_status_byindex(statuses, i);
//    std::cout<<"status: " << entry->index_to_workdir->status << "\tpath: "
//    << entry->index_to_workdir->new_file.path << std::endl;
//}

// git_status_list_free(statuses);


//unsigned int x_hours = 0;
//unsigned int x_minutes = 0;
//unsigned int x_seconds = 0;
//unsigned int x_milliseconds = 0;

//unsigned int totaltime = 0;
//unsigned int count_down_time_in_secs = 10; // 1 minute is 60, 1 hour is 3600
//unsigned int time_left = 0;

//clock_t x_startTime;
//clock_t x_countTime;

//x_startTime = clock();                           // start clock
//time_left = count_down_time_in_secs - x_seconds; // update timer

//while (time_left > 0) {
//    x_countTime = clock(); // update timer difference
//    x_milliseconds = x_countTime - x_startTime;
//    x_seconds = (x_milliseconds / (CLOCKS_PER_SEC)) - (x_minutes * 60);
//    x_minutes = (x_milliseconds / (CLOCKS_PER_SEC)) / 60;
//    x_hours = x_minutes / 60;
//    time_left =
//        count_down_time_in_secs - x_seconds; // subtract to get difference
//    // printf( "\nYou have %d seconds left ( %d ) count down timer by
//    // TopCoder",time_left,count_down_time_in_secs);
//}







//show_status_of_git_repo(files);

//#include <git2.h>
//#include <stdio.h>
//#include <string.h>
//#include <unistd.h>

//#include "cb_array.h"
//#include "cb_daemon.h"
//#include "cb_file.h"
//#include "cb_log.h"
//#include "cb_nuklear.h"


//for(int j=0; j < vector.size; j++){
//    printf("\nString at: %d is %s", j, vector.data[j]);
//}

//char** project_address = (char** ) malloc (1 * sizeof(char*));
//project_address[0] = (char* ) malloc (256 * sizeof(char));
//strcpy(project_address[0], "/mnt/D/WorkSpace/C/CaptainBallard");
//show_status_of_git_repo(project_address);


//    // show_nuklear_window();
//    // log_message(LOG_FILE, "Time's out.\n");
//printf("\n*** %s ****", buf);






//SHUTDOWN:
//    git_repository_free(rep);
//    git_libgit2_shutdown();
//    return 0;




//error = git_repository_open(&rep, buf);
//if (error < 0) {
//    const git_error *e = giterr_last();
//    printf("Error: %d : %s", e->klass, e->message);
//    goto SHUTDOWN;
//}

//        git_status_list *status;
//        struct opts o = {GIT_STATUS_OPTIONS_INIT, "."};
//
//        o.statusopt.show = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;
//        o.statusopt.flags = GIT_STATUS_OPT_INCLUDE_UNTRACKED |
//            GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX |
//            GIT_STATUS_OPT_SORT_CASE_SENSITIVELY;
//
//        parse_opts(&o, argc, argv);
//
//        if (git_repository_is_bare(repo))
//            fatal("Cannot report status on bare repository", git_repository_path(repo));
//
//show_status:
//        if (o.repeat)
//            printf("\033[H\033[2J");
//
//
//
//        lg2_status(rep, 1, address);


//int status_cb(const char *path, unsigned int status_flags, void *payload) {
//    printf("\n\nflag: %d", status_flags);
//    printf(", path: %s", path);
//    return 0;
//}


////size_t count = 0;
//int error = 0;
//git_status_options opt = GIT_STATUS_OPTIONS_INIT;

//git_libgit2_init();
//git_repository *rep;
//git_status_list *statuses;

////initArray(&a, 1); // initially 5 elements
//while (fgets(buf, sizeof(buf), fp) != NULL) {
//    buf[strlen(buf) - 1] = '\0'; // eat the newline fgets() stores
//    //insertArray(&a, buf);        // automatically resizes as necessary

//    // show_nuklear_window();
//    // log_message(LOG_FILE, "Time's out.\n");

//    printf("\n*** %s ****", buf);
//    // git open
//    error = git_repository_open(&rep, buf);
//    if (error < 0)
//    {
//        const git_error *e = giterr_last();
//        printf("Error: %d : %s",  e->klass, e->message);
//        goto SHUTDOWN;
//    }

//    // simple
//    error = git_status_foreach(rep, status_cb, NULL);
//    if (error < 0)
//    {
//        const git_error *e = giterr_last();
//        printf("Error: %d : %s",  e->klass, e->message);
//    }
//}
//fclose(fp);
//return 0;

//SHUTDOWN:
//    git_repository_free(rep);
//    git_libgit2_shutdown();
//    return 0;





//printf("%s\n", buf);
//printf("Internal Size: %d", a.used);

// read_file_line_by_line(full_address, &a);
//printf("Size: %d", a.used);
// printf(*&a.array[1]);
// for(int i=0; i<a.size; i++){
//}

// read_file_line_by_line(full_address);


//char** project_address;
//project_address = (char**)malloc(2048);
//project_address[0] = "/mnt/D/WorkSpace/C/NeoDM";



//Array a;
// declare and initialize a new vector
//Vector vector;
//vector_init(&vector);


/* add some elements to the back */
//vector_push_back(files, "linarcx");
//vector_push_back(files, "max");
//vector_push_back(files, "james");
//vector_pop_back(files);


// FILE *fp;
// char* buffer;

// fp = fopen(path, "r");
// while (fgets(buffer, 255, (FILE *)fp)) {
//     printf("%s\n", buffer);
// }

// //    while (fgets(buf, sizeof(buf), fp) != NULL) {


//if(projects && files && vector_size(files) > 1) {
//    for(size_t i = 0; i < vector_size(projects); i++) {
//        for(size_t j = 0; j < vector_size(files); j++) {
//            printf("v[%lu][%lu] = %s\n", i, j,  projects[i][j]);
//        }
//    }
//}


//vector_push_back(files, "test");
//printf("capacity: %lu\n", vector_capacity(files));
//printf("size    : %lu\n", vector_size(files));

//project_status(rep, &*files);

